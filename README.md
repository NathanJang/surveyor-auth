# surveyor-auth
A protocol and implementation of token-based digital authentication in surveys/elections.

## API
```javascript
var SurveyorAuth = require('surveyor-auth');
var surveyorAuth = new SurveyorAuth('private key here');
var token = surveyorAuth.generateTokenWithId(5); // or any ID
var tokenString = token.toString();
var tokensArray = surveyorAuth.generateTokensWithIdRange(0, 100); // toString() them yourself
var tokenIsVerified = surveyorAuth.verifyTokenWithId(5, token);
```

See [`index.js`](index.js) for more details.

### CLI
```bash
$ npm install -g https://github.com/NathanJang/surveyor-auth.git
# Outputs JSON
$ surveyor-auth --generate --key 'private key here' --id 5
$ surveyor-auth --generate-range --key 'private key here' --id 0 --to 100
$ surveyor-auth --verify --key 'private key here' --id 5 --token 6f4c93509d
# Save it to a file
$ surveyor-auth --generate-range --key 'private key here' --id 0 --to 100 > tokens.json
```

## Installation
```bash
$ npm install https://github.com/NathanJang/surveyor-auth
# or
$ npm install -g https://github.com/NathanJang/surveyor-auth
```

## Problem
When conducting a survey or election, 3 things must be considered:

* Authenticity: Only certain people may vote, and anyone may only vote once.
* Verifiability: Everyone must be certain that his/her individual vote were counted.
* Anonymity: Any vote must be anonymous for people to freely express their opinions.

This utility allows these factors to be considered in an online environment, even if a user chooses not to incorporate any of these factors.

## Procedure
1. Generate a bunch of tokens.
2. Shuffle the tokens.
3. Distribute them randomly to voters without taking down their names.
4. Voters submit votes online with the token, without identifying themselves.

## Protocol
Each token shall be serialised, each with a unique ID.

A salt length and hash length must be decided upon first, which are 2 and 8 by default, respectively.
This gives us 16^10 possible combinations, 16^2 valid tokens for each ID, and a 2 * 10^-8 % chance that a random guess is correct.
However, the hashing process is done 4 times by default, so brute-forcing the private key becomes 4 times as difficult as doing it once.
Assuming [15.8 cycles per byte](http://www.cryptopp.com/benchmarks.html), 70 bytes per hashing iteration, a CPU speed of [3.4GHz](http://processors.specout.com/l/1190/Intel-i7-4930k), 4 iterations per token generation, that SHA256 will not be broken, [Moore's Law does not hold true](http://www.extremetech.com/computing/165331-intels-former-chief-architect-moores-law-will-be-dead-within-a-decade), and that quantum computing (or something) will not be used, it will take an average of 4.78 * 10^63 years to brute force a private key, [by which time the survey will probably be closed](https://en.wikipedia.org/wiki/Heat_death_of_the_universe#Time_frame_for_heat_death).
Of course, this can be reduced to a year with 4.78 * 10^63 high-end processors, but it is infeasible.
The longer the salt, the lower possibility of a dictionary attack but the more valid tokens there will be for each ID;
2 and 8 are reasonable choices.

A private key must also be chosen *that must not be revealed to the public*.

To generate a token, 3 values are concatenated in a string, separated by underscores `_`:

* ID (decimal string)
* private key (string)
* salt (lowercase hexadecimal)

This string is then hashed with SHA256.
This process is repeated by replacing the private key with the previous SHA256 hash, for 4 times by default.
A final token is generated by concatenating the salt directly with an initial substring of the resultant SHA256 hash.

It is assumed that all strings are encoded UTF-8.

### Example
* private key: `oh one one eight nine nine nine`
* ID: `3`
* salt: `6f`
* 1st iteration
** value to hash: `3_oh one one eight nine nine nine_6f`
** SHA256: `4c93509dd6540168e2aa36d48081b2b075e386122e365dcfffacafafe3909727`
* 2nd iteration
** value to hash: `3_4c93509dd6540168e2aa36d48081b2b075e386122e365dcfffacafafe3909727_6f`
** SHA256: `40ec22884e8a018cf0e5648085fbd423de36b07ce7663591690785fd3d8dcd8d`
* 3rd iteration
** value to hash: `3_40ec22884e8a018cf0e5648085fbd423de36b07ce7663591690785fd3d8dcd8d_6f`
** SHA256: `21b1f6f09c644ea720117d130a21de3421a80f4463ddd0d11330a51cd5d66ffc`
* 4th iteration
** value to hash: `3_21b1f6f09c644ea720117d130a21de3421a80f4463ddd0d11330a51cd5d66ffc_6f`
** SHA256: `6def0cf701fd4edc637cbab4bb3b8e26cd901878fae0d89fca7b1e02b275be4c`
* hash substring: `6def0cf7`
* token: salt + hash substring: `6f6def0cf7`
