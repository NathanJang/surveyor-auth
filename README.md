# surveyor-auth
A protocol and implementation of token-based digital authentication in surveys/elections.

## API
```javascript
var SurveyorAuth = require('surveyor-auth');
var surveyorAuth = new SurveyorAuth('private key here');
var token = surveyorAuth.generateTokenWithId(5); // or any ID
var tokenString = token.toString();
var tokensArray = surveyorAuth.generateTokensWithIdRange(0, 100); // toString() them yourself
var tokenIsVerified = surveyorAuth.verifyTokenWithId(5, token);
```

See [`index.js`](index.js) for more details.

### CLI
```bash
$ npm install -g https://github.com/NathanJang/surveyor-auth.git
# Outputs JSON
$ surveyor-auth --generate --key 'private key here' --id 5
$ surveyor-auth --generate-range --key 'private key here' --id 0 --to 100
$ surveyor-auth --verify --key 'private key here' --id 5 --token 6f4c93509d
# Save it to a file
$ surveyor-auth --generate-range --key 'private key here' --id 0 --to 100 > tokens.json
```

## Problem
When conducting a survey or election, 3 things must be considered:

* Authenticity: Only certain people may vote, and anyone may only vote once.
* Verifiability: Everyone must be certain that his/her individual vote were counted.
* Anonymity: Any vote must be anonymous for people to freely express their opinions.

This utility allows these factors to be considered in an online environment, even if a user chooses not to incorporate any of these factors.

## Procedure
1. Generate a bunch of tokens.
2. Shuffle the tokens.
3. Distribute them randomly to voters without taking down their names.
4. Voters submit votes online with the token, without identifying themselves.

## Protocol
Each token shall be serialised, each with a unique ID.

A salt length and hash length must be decided upon first, which are 2 and 8 by default, respectively.
This gives us 16^10 possible combinations, 16^2 valid tokens for each ID, and a 2 * 10^-8 % chance that a random guess is correct.
Assuming 0.5 seconds per hash, it will take an average of 68 years to brute force a valid token, by which time the survey will probably be closed.
The longer the salt, the lower possibility of a dictionary attack but the more valid tokens there will be for each ID;
2 and 8 are reasonable choices.

A private key must also be chosen *that must not be revealed to the public*.

To generate a token, 3 values are concatenated in a string, separated by underscores `_`:

* ID (decimal string)
* private key (string)
* salt (lowercase hexadecimal)

This string is then hashed with SHA256.
A final token is generated by concatenating the salt directly with an initial substring of the resultant SHA256 hash.

It is assumed that all strings are encoded UTF-8.

### Example
* private key: `oh one one eight nine nine nine`
* ID: `3`
* salt: `6f`
* value to hash: `3_oh one one eight nine nine nine_6f`
* SHA256: `4c93509dd6540168e2aa36d48081b2b075e386122e365dcfffacafafe3909727`
* hash substring: `4c93509d`
* token: `6f4c93509d`
